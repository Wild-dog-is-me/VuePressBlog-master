## 1. Java语言的特点

- 跨平台性，java在运行时跟os没有直接联系，是在jvm虚拟机上运行的，不同平台的有不同的java虚拟机，可以将编译后的字节码文件转化为机器最终可识别的机器语言，所以说java的跨平台性的特性是由java虚拟机实现的，也就是说让代码实现一次编写、各主流os运行。
- 从高级语言本身，它不像底层语言C 直接操作内存，避免了内存溢出等问题
- 支持多线程
- 高性能GC垃圾回收器
- 面向对象
- 框架生态丰富

## 2. JRE是什么

Java 的运行环境，包括Java 虚拟机以及标准类库

## 3. JDK是什么

java开发工具包，包括jre，java工具命令，基础类库

## 4. Java虚拟机

Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也**未必由**Java语言编译而成，像Scala等语言生成的Java字节码也可以由Java虚拟机执行。

Java虚拟机大概有以下几个部分：

- 定义了虚拟机的内部结构
- 定义了虚拟机执行的字节码类型和功能
- 定义了Class文件的结构
- 定义了类的装载、连接和初始化

## 5. Java虚拟机的生命周期

（起点）JVM通过调用某个类的公有的、静态、无返回值类型、接收参数为字符串数组的main()方法来运行一个Java 程序

（运行）即使使用多线程也需要从这个初始线程main()方法中创建，JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，垃圾回收线程就是守护线程，并且这种线程并不属于程序中不可或缺的部分。

（消亡）因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。若安全管理器允许，程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出。

## 6. 基本数据类型

- 数值型：
    - 整数 byte short int long（依次从小到大）
    - 浮点 float double
- 字符型 char
- 布尔型 boolean

## 7. 引用数据类型

类（String是引用数据类型）、接口、数组

## 8. *++变量* 和*变量++*

++变量：变量在参与其他操作前先将自己加1

变量++：先把变量值赋给其他变量，再将自己加1

## 9. 什么是方法

方法是完成某个功能的一组语句

## 10. 方法的定义：

```java
访问修饰符 返回值类型 方法名(参数){
   方法体 ...
}
```

## 11. 方法的分类

- 无返回值无参数的
- 无返回值有参数的，括号里为形式参数
- 有返回值无参数
- 有返回值有参数

## 12. 使用方法的注意事项

- 形参写明数据类型
- return返回值类型必须与方法返回值类型相同，一个方法中只能返回一次，且执行到return方法结束
- 方法是不能嵌套的

## 13. 方法重载

在同一个类中允许多个同名的方法存在

重载的原则：

- 方法名相同
- 参数不同：类型不同或个数不同
- 返回值可以相同也可以不相同

## 14. 重写和重载的区别

**重载发生在同一个类中**，若多个方法之间方法名相同、参数列表不同，则它们构成重载的关系。重载与方法的返回值以及访问修饰符无关

**重写发生在父类子类中**，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。另外，返回值要小于等于父类方法，抛出的异常要小于等于父类方法，访问修饰符则要大于等于父类方法。还有，若父类方法的访问修饰符为private，则子类不能对其重写。

## 15. switch接收的参数

java5之前，只接收byte short int char，java5之后引入了枚举类，switch参数可以接受枚举类型，java7之后，switch还可以接受string类型，至目前还没有一个版本能够接受长整型long类型。

## 16. 循环的三要素

**变量的初始化 、变量的迭代 、循环条件**

## 17. 嵌套循环

外层循环是**行**、内层循环是**列**

执行流程：外层循环一次，内层循环要循环一遍。

## 18. break和continue的区别

break不再执行循环体中break后边的语句，跳出循环

continue不再执行循环体中continue后边的语句，进入下一次循环

## 19. 面向对象思想的理解

类、对象、继承、消息，尽可能让系统设计中使用人类自然的思维方式，强调直接已现实世界中的事物来思考业务，使得系统组件可以直接映像到客观世界

## 20. 面向对象的三大特征是什么？

封装、继承、多态

## 20.1 封装

封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能

### 封装的意义：

- 隐藏类的实现细节，实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。
- 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；
- 可进行数据检查，从而有利于保证对象信息的完整性；
- 便于修改，提高代码的可维护性。

## 20.2 继承

继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法，同时可以增加自己的属性和方法

### Java为什么是单继承，为什么不能多继承？

首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。

其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。

准确来说，Java是可以实现"多继承"的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。

### 子类实例化过程：

子类实例化先实例化父类、再实例化子类，先调用父类中的构造器、再调用子类的构造器

### supper关键字

作用：调用父类的构造器，只能出现在子类构造器第一行，参数决定调用父类中的哪个构造器

## 20.3 多态

多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。

### 对多态的理解：

当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。

### 多态的三个必要条件：

- 要有继承或者实现
- 要有重写
- 父类的引用指向子类的对象

## 21. 引用数据类型的转换

**向上转型**（自动类型转换）：子类转换成父类

特点：损失了子类扩展的属性和方法，只能使用父类中继承的属性和方法。

------

**向下转型**（强制类型转换）：将父类对象显示的转换成子类对象

特点：想要向下转型必须要经过一次向上转型，发生向下转型后字了可以调用父类中的属性和方法，自己的属性和方法也可以调用。

## 22. 抽象

抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。

## 23. 类和对象的关系

类是一组具有相同属性和行为的对象的抽象，对象是描述客观事物的一个实体

类的作用是以模板的角色去创建对象，对象是类的实例

类中定义的属性在对象中被赋值，类中定义的方法行为，在对象中被激活。

## 24. 变量分类

**在类中、方法外定义的变量**叫做成员变量，在本类中都可以被访问。

**在方法中定义的变量**叫局部变量，只能在本方法中被访问。

**类中声明为static的属性**叫做静态变量

## 25. Static的用法

用法1：static修饰方法>静态方法，不能访问类的非静态成员变量和非静态成员方法，反过来可以

用法2：static修饰变量>静态变量，被所有对象共享，在内存中只有一个副本，仅在类初次加载被初始化

用法3：static修饰代码块，类中可以有多个static块，在类初次被加载时，会按照static块的顺序来依次执行每个static块，并且只会执行一次。

## static的注意事项

- 静态方法里只能直接访问静态成员，不能直接访问类中的非静态成员
- 静态方法中不能使用this、super关键字
- 静态方法不能被非静态方法覆盖，静态方法不能修饰构造器

### 什么是静态代码块？

- 一个类中由static关键字修饰的，不包含在任何方法体中的代码块
- 当类被载入时，静态代码块被执行，且只执行一次
- 静态块经常用来进行类属性的初始化

## 26. 构造器的特点和作用

特点：同类名、无返回值、访问权限一般是public

作用：完成对象的创建、实例化，通过构造器的形参可以对成员变量赋值

## 27. 构造方法能不能重写？

**不能**。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。

## 28. this关键字

用法1：**this.属性** 当局部变量和成员变量出现了重名问题，Java会根据就近原则，优先使用局部变量，例如构造方法中，非要使用成员变量的话，可以使用this关键字进行区分

用法2：**this.方法** 除了静态方法中不可使用，本类其他方法包括私有方法均可使用此格式调用其他方法，只是我们通常省略this关键字。

用法3：**this()** 用于构造方法内，例如可以在无参构造内调用含参构造，那么这时候就需要在this()传入参数来实现，同理要想在含参构造内调用无参构造，只需在构造器代码第一行写this()即可，但this()与this(参数列表)不可同时使用！

## 29. 权限访问操作符

只有default和public能够用来修饰类。修饰类的变量和方法四种权限都可以。

- 修饰类
    - default：表示在同一包中其他类都可以访问该类。
    - public：表示任何一个类都可以访问该类。
- 修饰方法和变量：
    - private：只能在本类访问，其他类不能访问。
    - default：只能在同包的类中可以访问到类的方法和变量，而不同包的类则不能访问类的方法和变量。
    - protected：既能提供本类访问，又能提供给不同包继承于此类的类访问方法和变量。
    - public：任意类能访问方法和变量。

## 30. final关键字的作用

修饰类，不能被继承

修饰变量，不能被重新赋值

修饰方法，不能被重写

> 常量命名规范，所有字母大写，单词之间用下划线

## 31. abstract抽象类和抽象方法

## 抽象类的规则：

- 抽象类不能被实例化
- 父类中包含的抽象方法必须在子类中实现，否则子类声明成抽象方法
- 抽象方法不能用static修饰

## 在什么情况下必须声明成抽象类？

- 当类中有抽象方法时
- 当类是抽象类的子类且没有实现父类的所有抽象方法
- 当一个类实现一个接口且不能为全部抽象方法都提供实现时

## 32. 接口

- 接口中只能包含常量和抽象方法
- 接口对类来说是一套规范，是一套行为协议；
- 接口不是类，不能被实例化
- 接口中默认常量的修饰是：public static final
- 接口中的方法默认是abstract
- 接口可以但继承接口也可以继承多个接口，不能继承类

## 类和接口的特点：

- 为了使用一个接口，你要编写实现接口的类
- 如果一个类要实现一个接口，那么这个类就必须实现接口中所有抽象方法。否则这个类只能声明为抽象类
- 多个无关的类可以实现一个接口，一个类可以实现多个无关的接口
- 一个类可以在继承一个父类的同时，实现一个或多个接口

## 33. 接口和抽象类的区别

## 从设计目的上来说，二者有如下的区别：

接口体现的是一种规范：

对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。

当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。

------

抽象类体现的是一种模板式设计：

抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。

## 从使用方式上来说，二者有如下的区别：

- 接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。
- 接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。
- 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
- 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。
- 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。

## 34. 内存模型（待补充）

栈：存取速度比堆快、效率高，栈内保存**基本数据类型的局部变量**和**对象的引用**，值先进后出，使用完毕立即回收

堆：保存对空间要求较大的变量，例如对象的属性和数组的元素，先进先出，在堆内存中开辟空间，只能通过new。数据使用完毕后，会在垃圾回收期空闲的时候回被回收

java中在类的实例化过程中，内存中会使用这三个区域，栈区，堆区和方法区。

- 首先，累加载器在方法区加载Class信息，类中的成员变量和方法体进入到**方法区**。
- mian()方法体进入栈内存（压栈）
- 在堆内存开辟内存空间，用于存放类的实例对象，将成员变量和成员方法的地址值放到new实例中
- 没太懂、没写完....

## 35. GC垃圾回收机制

在Java内存运行时区域的各个部分中，堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，我们平时所说的内存分配与回收也仅仅特指这一部分内存。

## 36. 对象在什么情况下变成垃圾

一个对象被强引用，不会回收

一个对象被软引用，如果内存不足就会回收

一个对象被弱引用不管当前内存空间是否足够，只要gc扫描到随时会回收

一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收