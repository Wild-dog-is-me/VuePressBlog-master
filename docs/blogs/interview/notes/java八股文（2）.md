## 1. Java中有哪些容器（集合类）

Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection接口又派生出三个子接口，分别是Set、List、Queue。所有的Java集合类，都是Set、List、Queue、Map这四个接口的实现类，这四个接口将集合分成了四大类，其中

- Set代表无序的，元素不可重复的集合；
- List代表有序的，元素可以重复的集合；
- Queue代表先进先出（FIFO）的队列；
- Map代表具有映射关系（key-value）的集合。

## 2. 集合和数组的区别:

- 数组也是容器，是定长的，访问较快。但是不能自动扩容
- 集合不是定长的，可以自动扩容
- 数组可以包含基本数据类型和引用数据类型，但是集合只能包含引用数据类型

## 3. ArrayList和LinkedList的区别：

- ArrayList类实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高
- LinkedList类采用双向链表存储方式。插入、删除元素时效率比较高
- LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。

## 4. 说一说TreeSet和HashSet的区别

HashSet、TreeSet中的元素都是不能重复的，并且它们都是线程不安全的，二者的区别是：

- HashSet中的元素可以是null，但TreeSet中的元素不能是null
- HashSet不能保证元素的排列顺序，而TreeSet支持自然排序、定制排序两种排序的方式
- HashSet底层是采用哈希表实现的，而TreeSet底层是采用红黑树实现的

## 5. Iterator

实现集合的遍历，迭代器 it 的基本操作是 next 、hasNext 和 remove。

调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。

调用 it.hasNext() 用于检测集合中是否还有元素。

调用 it.remove() 将迭代器返回的元素删除。

## 6. 说一说HashMap和HashTable的区别

Hashtable是一个线程安全的Map实现，但HashMap是线程不安全的实现，所以HashMap比Hashtable的性能高一点

Hashtable不允许使用null作为key和value，如果试图把null值放进Hashtable中，将会引发空指针异常，但HashMap可以使用null作为key或value

## 7. 为什么出现泛型？

泛型就是集合添加数据的类型约束。

集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。`Collection<E>`，`List<E>`，`ArrayList<E>`这个`<E>`就是类型参数，即泛型。

## 8. 介绍一下Java中的IO流

IO（Input Output）用于实现对数据的输入与输出操作，Java把不同的输入/输出源（键盘、文件、网络等）抽象表述为流（Stream）。流是从起源到接收的有序数据。

- 按照数据流向，可以将流分为输入流和输出流，其中输入流只能读取数据，而输出流只能写入数据
- 按照数据类型，可以将流分为字节流和字符流，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。
- 按照处理功能，可以将流分为节点流和处理流，其中节点流可以直接从/向一个特定的IO设备（磁盘、网络等）读/写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也称为高级流。

## 9. 流的4个父类

字节输入流的父类：Inputstream

字节输出流：Outputstream

字符输入流：Reader

字符输出流：Writer

## 10. 怎么用流打开一个大文件？

打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采用分次读取的方式。

- 使用缓冲流。缓冲流内部维护了一个缓冲区，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它每次会读取一批数据将缓冲区填满，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备。
- 使用NIO。NIO采用内存映射文件的方式来处理输入/输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多。

## 11. 介绍一下Java的序列化与反序列化

序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。其中，对象的序列化（Serialize），是指将一个Java对象写入IO流中，对象的反序列化（Deserialize），则是指从IO流中恢复该Java对象。

若对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。

若要实现序列化，则需要使用对象流ObjectInputStream和ObjectOutputStream。其中，在序列化时需要调用ObjectOutputStream对象的writeObject()方法，以输出对象序列。在反序列化时需要调用ObjectInputStream对象的readObject()方法，将对象序列恢复为对象。

## 12. Serializable接口为什么需要定义serialVersionUID变量？

serialVersionUID代表序列化的版本，通过定义类的序列化版本，在反序列化时，只要对象中所存的版本和当前类的版本一致，就允许做恢复数据的操作，否则将会抛出序列化版本不一致的错误。

如果不定义序列化版本，在反序列化时可能出现冲突的情况，例如：

- 创建该类的实例，并将这个实例序列化，保存在磁盘上；
- 升级这个类，例如增加、删除、修改这个类的成员变量；
- 反序列化该类的实例，即从磁盘上恢复修改之前保存的数据。

在第3步恢复数据的时候，当前的类已经和序列化的数据的格式产生了冲突，可能会发生各种意想不到的问题。增加了序列化版本之后，在这种情况下则可以抛出异常，以提示这种矛盾的存在，提高数据的安全性。