{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{283:function(a,t,_){\"use strict\";_.r(t);var v=_(10),s=Object(v.a)({},(function(){var a=this,t=a._self._c;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"_1-说说mybatis的三层\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-说说mybatis的三层\"}},[a._v(\"#\")]),a._v(\" 1. 说说Mybatis的三层\")]),a._v(\" \"),t(\"p\",[a._v(\"MyBatis主要分为三层：\"),t(\"strong\",[a._v(\"接口层，数据处理层与基础层\")]),a._v(\"。\")]),a._v(\" \"),t(\"p\",[a._v(\"接口层是通过提供的API作为数据库进行增/删/改/查，都是MyBatis的API。提供主要用的两个接口：\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"SqlSessionFactory：它是通过configration构造的接口对象，然后通过该接口对象构造SqlSession对象。\")]),a._v(\" \"),t(\"li\",[a._v(\"SqlSession:作用是提供加载映射文件中的mapperstatement对象。并提供增删改查的方法\")])]),a._v(\" \"),t(\"p\",[a._v(\"数据处理层是SQL预处理、SQL执行、结果映射。\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"SQL预处理：是对代码里的变量进行绑定，以及动态SQL生成\")]),a._v(\" \"),t(\"li\",[a._v(\"SQL执行：是把生成好的SQL，通过JDBC驱动，传到对应的DB里执行，而且要负责网络通信的部分\")]),a._v(\" \"),t(\"li\",[a._v(\"结果映射：是把数据库返回的结果从关系型数据转换成Java对象数据。\")])]),a._v(\" \"),t(\"p\",[a._v(\"基础层包括日志、事务管理、缓存、连接池、动态代理、配置解析。\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"日志：是做框架里面的日志输出以及SQL语句输出\")]),a._v(\" \"),t(\"li\",[a._v(\"事务管理：是对 JDBC事务、数据库事物做管理；\")]),a._v(\" \"),t(\"li\",[a._v(\"缓存：能够把结果集缓存在JVM的内存。优点是比较快，缺点是会占用堆内存。实际上一般使用Redis这样的中间件来做分布式缓存\")]),a._v(\" \"),t(\"li\",[a._v(\"连接池：能够加速查询，提高性能\")]),a._v(\" \"),t(\"li\",[a._v(\"动态代理：在用MyBatis编程时，核心是通过接口执行数据库查询。而Mapper接口本身是没有实现的，通过注解或者XML配置SQL语句，动态代理会在运行时生成代理，当调用Mapper接口时，转换成实际的SQL语句\")]),a._v(\" \"),t(\"li\",[a._v(\"配置解析：因为MyBatis里面有存在大量配置，需要配置新模块，读取XML配置，并把它映射为配置属性。\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_2-mybatis的映射过程\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-mybatis的映射过程\"}},[a._v(\"#\")]),a._v(\" 2. Mybatis的映射过程\")]),a._v(\" \"),t(\"p\",[a._v(\"加载sql语句，获取表中数据然后将数据返回给结果集，从结果集中获取数据（取出每个字段），通过构造器给对象赋值\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_3-mybatis的事务管理类型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-mybatis的事务管理类型\"}},[a._v(\"#\")]),a._v(\" 3. Mybatis的事务管理类型\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"原生JDBC，对应的事务相关操作都由mybatis内置的\"),t(\"code\",[a._v(\"JdbcTransaction\")]),a._v(\"来完成，\")]),a._v(\" \"),t(\"li\",[a._v(\"MANAGED，对事务的管理是一个空实现，将事务管理交给外部容器，例如交给Spring来实现，\")])]),a._v(\" \"),t(\"p\",[a._v(\"无论是哪种方式，都是使用jdk利用数据库的Connection来提供管理事务的能力，都是一层一层的封装进行委派最终由Connection的具体数据库驱动来进行实现的\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_4-mybatis的数据源\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-mybatis的数据源\"}},[a._v(\"#\")]),a._v(\" 4. Mybatis的数据源\")]),a._v(\" \"),t(\"p\",[t(\"strong\",[a._v(\"POOLED\")]),a._v(\"：采用传统的javax.sql.DataSource规范中的连接池，对连接进行了缓存\")]),a._v(\" \"),t(\"p\",[t(\"strong\",[a._v(\"UNPOOLED\")]),a._v(\"：采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想\")]),a._v(\" \"),t(\"p\",[t(\"strong\",[a._v(\"JNDI\")]),a._v(\"：采用服务器提供的JNDI技术实现，来获取DataSource对象，通过JNDI上下文中取值\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_5-连接池思想\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-连接池思想\"}},[a._v(\"#\")]),a._v(\" 5. 连接池思想\")]),a._v(\" \"),t(\"p\",[a._v(\"创建一个Conncection代价是巨大的，因为创建了一个连接，在底层就与数据库建立了通信连接，\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"TCP 建立连接 三次握手\")]),a._v(\" \"),t(\"li\",[a._v(\"MySql 认证的 三次握手\")]),a._v(\" \"),t(\"li\",[a._v(\"SQL 的执行\")]),a._v(\" \"),t(\"li\",[a._v(\"MySql 的关闭\")]),a._v(\" \"),t(\"li\",[a._v(\"TCP 的 四次握手 关闭连接\")])]),a._v(\" \"),t(\"p\",[a._v(\"网络IO较多，数据库的负载较高、应用频繁的创建连接和关闭连接，导致临时对象较多，GC频繁，所以说是非常消耗资源的操作，从用户的角度来讲，导致响应时间较长以及QPS较低 ，而为数据库建立一个“连接池”，预先创建一定数量的连接，当需要连接时，只需从中取出一个，使用完毕之后再放回，避免了连接随意建立和关闭造成的系统开销。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_6-连接池原理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-连接池原理\"}},[a._v(\"#\")]),a._v(\" 6. 连接池原理\")]),a._v(\" \"),t(\"p\",[a._v(\"服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。\\n客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。\\n如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由具体的配置参数决定。\\n当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_7-mybatis是怎么将mapper与xml联系起来的\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-mybatis是怎么将mapper与xml联系起来的\"}},[a._v(\"#\")]),a._v(\" 7. Mybatis是怎么将mapper与xml联系起来的\")]),a._v(\" \"),t(\"p\",[a._v(\"当加载映射文件时，会将每个sql标签加载成不同的MapperStatement对象。MapperStatement对象的id = namespace（接口的全限定名） + mapper的方法名，在MyBatis中，每一个< select>、< insert>、< update>、< delete>标签都会被解析为一个MapperStatement对象\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_8-mybatis输入输出支持的类型有哪些\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-mybatis输入输出支持的类型有哪些\"}},[a._v(\"#\")]),a._v(\" 8. MyBatis输入输出支持的类型有哪些？\")]),a._v(\" \"),t(\"p\",[a._v(\"parameterType：\")]),a._v(\" \"),t(\"p\",[a._v(\"MyBatis支持多种输入输出类型，包括：\")]),a._v(\" \"),t(\"ol\",[t(\"li\",[a._v(\"简单的类型，如整数、小数、字符串等；\")]),a._v(\" \"),t(\"li\",[a._v(\"集合类型，如Map等；\")]),a._v(\" \"),t(\"li\",[a._v(\"自定义的JavaBean。\")])]),a._v(\" \"),t(\"p\",[a._v(\"其中，简单的类型，其数值直接映射到参数上。对于Map或JavaBean则将其属性按照名称映射到参数上。\")])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}