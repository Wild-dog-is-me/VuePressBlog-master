{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{277:function(a,_,v){\"use strict\";v.r(_);var t=v(10),s=Object(t.a)({},(function(){var a=this,_=a._self._c;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[_(\"h2\",{attrs:{id:\"_1-java语言的特点\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-java语言的特点\"}},[a._v(\"#\")]),a._v(\" 1. Java语言的特点\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"跨平台性，java在运行时跟os没有直接联系，是在jvm虚拟机上运行的，不同平台的有不同的java虚拟机，可以将编译后的字节码文件转化为机器最终可识别的机器语言，所以说java的跨平台性的特性是由java虚拟机实现的，也就是说让代码实现一次编写、各主流os运行。\")]),a._v(\" \"),_(\"li\",[a._v(\"从高级语言本身，它不像底层语言C 直接操作内存，避免了内存溢出等问题\")]),a._v(\" \"),_(\"li\",[a._v(\"支持多线程\")]),a._v(\" \"),_(\"li\",[a._v(\"高性能GC垃圾回收器\")]),a._v(\" \"),_(\"li\",[a._v(\"面向对象\")]),a._v(\" \"),_(\"li\",[a._v(\"框架生态丰富\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_2-jre是什么\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-jre是什么\"}},[a._v(\"#\")]),a._v(\" 2. JRE是什么\")]),a._v(\" \"),_(\"p\",[a._v(\"Java 的运行环境，包括Java 虚拟机以及标准类库\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_3-jdk是什么\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-jdk是什么\"}},[a._v(\"#\")]),a._v(\" 3. JDK是什么\")]),a._v(\" \"),_(\"p\",[a._v(\"java开发工具包，包括jre，java工具命令，基础类库\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_4-java虚拟机\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-java虚拟机\"}},[a._v(\"#\")]),a._v(\" 4. Java虚拟机\")]),a._v(\" \"),_(\"p\",[a._v(\"Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也\"),_(\"strong\",[a._v(\"未必由\")]),a._v(\"Java语言编译而成，像Scala等语言生成的Java字节码也可以由Java虚拟机执行。\")]),a._v(\" \"),_(\"p\",[a._v(\"Java虚拟机大概有以下几个部分：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"定义了虚拟机的内部结构\")]),a._v(\" \"),_(\"li\",[a._v(\"定义了虚拟机执行的字节码类型和功能\")]),a._v(\" \"),_(\"li\",[a._v(\"定义了Class文件的结构\")]),a._v(\" \"),_(\"li\",[a._v(\"定义了类的装载、连接和初始化\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_5-java虚拟机的生命周期\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-java虚拟机的生命周期\"}},[a._v(\"#\")]),a._v(\" 5. Java虚拟机的生命周期\")]),a._v(\" \"),_(\"p\",[a._v(\"（起点）JVM通过调用某个类的公有的、静态、无返回值类型、接收参数为字符串数组的main()方法来运行一个Java 程序\")]),a._v(\" \"),_(\"p\",[a._v(\"（运行）即使使用多线程也需要从这个初始线程main()方法中创建，JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，垃圾回收线程就是守护线程，并且这种线程并不属于程序中不可或缺的部分。\")]),a._v(\" \"),_(\"p\",[a._v(\"（消亡）因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。若安全管理器允许，程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_6-基本数据类型\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-基本数据类型\"}},[a._v(\"#\")]),a._v(\" 6. 基本数据类型\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"数值型：\\n\"),_(\"ul\",[_(\"li\",[a._v(\"整数 byte short int long（依次从小到大）\")]),a._v(\" \"),_(\"li\",[a._v(\"浮点 float double\")])])]),a._v(\" \"),_(\"li\",[a._v(\"字符型 char\")]),a._v(\" \"),_(\"li\",[a._v(\"布尔型 boolean\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_7-引用数据类型\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-引用数据类型\"}},[a._v(\"#\")]),a._v(\" 7. 引用数据类型\")]),a._v(\" \"),_(\"p\",[a._v(\"类（String是引用数据类型）、接口、数组\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_8-变量-和变量\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-变量-和变量\"}},[a._v(\"#\")]),a._v(\" 8. \"),_(\"em\",[a._v(\"++变量\")]),a._v(\" 和\"),_(\"em\",[a._v(\"变量++\")])]),a._v(\" \"),_(\"p\",[a._v(\"++变量：变量在参与其他操作前先将自己加1\")]),a._v(\" \"),_(\"p\",[a._v(\"变量++：先把变量值赋给其他变量，再将自己加1\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_9-什么是方法\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-什么是方法\"}},[a._v(\"#\")]),a._v(\" 9. 什么是方法\")]),a._v(\" \"),_(\"p\",[a._v(\"方法是完成某个功能的一组语句\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_10-方法的定义\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-方法的定义\"}},[a._v(\"#\")]),a._v(\" 10. 方法的定义：\")]),a._v(\" \"),_(\"div\",{staticClass:\"language-java line-numbers-mode\"},[_(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[_(\"code\",[a._v(\"访问修饰符 返回值类型 方法名\"),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),a._v(\"参数\"),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"{\")]),a._v(\"\\n   方法体 \"),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),a._v(\"\\n\"),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"}\")]),a._v(\"\\n\")])]),a._v(\" \"),_(\"div\",{staticClass:\"line-numbers-wrapper\"},[_(\"span\",{staticClass:\"line-number\"},[a._v(\"1\")]),_(\"br\"),_(\"span\",{staticClass:\"line-number\"},[a._v(\"2\")]),_(\"br\"),_(\"span\",{staticClass:\"line-number\"},[a._v(\"3\")]),_(\"br\")])]),_(\"h2\",{attrs:{id:\"_11-方法的分类\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11-方法的分类\"}},[a._v(\"#\")]),a._v(\" 11. 方法的分类\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"无返回值无参数的\")]),a._v(\" \"),_(\"li\",[a._v(\"无返回值有参数的，括号里为形式参数\")]),a._v(\" \"),_(\"li\",[a._v(\"有返回值无参数\")]),a._v(\" \"),_(\"li\",[a._v(\"有返回值有参数\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_12-使用方法的注意事项\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12-使用方法的注意事项\"}},[a._v(\"#\")]),a._v(\" 12. 使用方法的注意事项\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"形参写明数据类型\")]),a._v(\" \"),_(\"li\",[a._v(\"return返回值类型必须与方法返回值类型相同，一个方法中只能返回一次，且执行到return方法结束\")]),a._v(\" \"),_(\"li\",[a._v(\"方法是不能嵌套的\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_13-方法重载\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_13-方法重载\"}},[a._v(\"#\")]),a._v(\" 13. 方法重载\")]),a._v(\" \"),_(\"p\",[a._v(\"在同一个类中允许多个同名的方法存在\")]),a._v(\" \"),_(\"p\",[a._v(\"重载的原则：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"方法名相同\")]),a._v(\" \"),_(\"li\",[a._v(\"参数不同：类型不同或个数不同\")]),a._v(\" \"),_(\"li\",[a._v(\"返回值可以相同也可以不相同\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_14-重写和重载的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_14-重写和重载的区别\"}},[a._v(\"#\")]),a._v(\" 14. 重写和重载的区别\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"重载发生在同一个类中\")]),a._v(\"，若多个方法之间方法名相同、参数列表不同，则它们构成重载的关系。重载与方法的返回值以及访问修饰符无关\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"重写发生在父类子类中\")]),a._v(\"，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。另外，返回值要小于等于父类方法，抛出的异常要小于等于父类方法，访问修饰符则要大于等于父类方法。还有，若父类方法的访问修饰符为private，则子类不能对其重写。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_15-switch接收的参数\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_15-switch接收的参数\"}},[a._v(\"#\")]),a._v(\" 15. switch接收的参数\")]),a._v(\" \"),_(\"p\",[a._v(\"java5之前，只接收byte short int char，java5之后引入了枚举类，switch参数可以接受枚举类型，java7之后，switch还可以接受string类型，至目前还没有一个版本能够接受长整型long类型。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_16-循环的三要素\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_16-循环的三要素\"}},[a._v(\"#\")]),a._v(\" 16. 循环的三要素\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"变量的初始化 、变量的迭代 、循环条件\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_17-嵌套循环\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_17-嵌套循环\"}},[a._v(\"#\")]),a._v(\" 17. 嵌套循环\")]),a._v(\" \"),_(\"p\",[a._v(\"外层循环是\"),_(\"strong\",[a._v(\"行\")]),a._v(\"、内层循环是\"),_(\"strong\",[a._v(\"列\")])]),a._v(\" \"),_(\"p\",[a._v(\"执行流程：外层循环一次，内层循环要循环一遍。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_18-break和continue的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_18-break和continue的区别\"}},[a._v(\"#\")]),a._v(\" 18. break和continue的区别\")]),a._v(\" \"),_(\"p\",[a._v(\"break不再执行循环体中break后边的语句，跳出循环\")]),a._v(\" \"),_(\"p\",[a._v(\"continue不再执行循环体中continue后边的语句，进入下一次循环\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_19-面向对象思想的理解\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_19-面向对象思想的理解\"}},[a._v(\"#\")]),a._v(\" 19. 面向对象思想的理解\")]),a._v(\" \"),_(\"p\",[a._v(\"类、对象、继承、消息，尽可能让系统设计中使用人类自然的思维方式，强调直接已现实世界中的事物来思考业务，使得系统组件可以直接映像到客观世界\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_20-面向对象的三大特征是什么\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-面向对象的三大特征是什么\"}},[a._v(\"#\")]),a._v(\" 20. 面向对象的三大特征是什么？\")]),a._v(\" \"),_(\"p\",[a._v(\"封装、继承、多态\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_20-1-封装\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-1-封装\"}},[a._v(\"#\")]),a._v(\" 20.1 封装\")]),a._v(\" \"),_(\"p\",[a._v(\"封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"封装的意义\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#封装的意义\"}},[a._v(\"#\")]),a._v(\" 封装的意义：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"隐藏类的实现细节，实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。\")]),a._v(\" \"),_(\"li\",[a._v(\"让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；\")]),a._v(\" \"),_(\"li\",[a._v(\"可进行数据检查，从而有利于保证对象信息的完整性；\")]),a._v(\" \"),_(\"li\",[a._v(\"便于修改，提高代码的可维护性。\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_20-2-继承\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-2-继承\"}},[a._v(\"#\")]),a._v(\" 20.2 继承\")]),a._v(\" \"),_(\"p\",[a._v(\"继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法，同时可以增加自己的属性和方法\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"java为什么是单继承-为什么不能多继承\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java为什么是单继承-为什么不能多继承\"}},[a._v(\"#\")]),a._v(\" Java为什么是单继承，为什么不能多继承？\")]),a._v(\" \"),_(\"p\",[a._v(\"首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。\")]),a._v(\" \"),_(\"p\",[a._v(\"其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。\")]),a._v(\" \"),_(\"p\",[a._v('准确来说，Java是可以实现\"多继承\"的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。')]),a._v(\" \"),_(\"h3\",{attrs:{id:\"子类实例化过程\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#子类实例化过程\"}},[a._v(\"#\")]),a._v(\" 子类实例化过程：\")]),a._v(\" \"),_(\"p\",[a._v(\"子类实例化先实例化父类、再实例化子类，先调用父类中的构造器、再调用子类的构造器\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"supper关键字\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#supper关键字\"}},[a._v(\"#\")]),a._v(\" supper关键字\")]),a._v(\" \"),_(\"p\",[a._v(\"作用：调用父类的构造器，只能出现在子类构造器第一行，参数决定调用父类中的哪个构造器\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_20-3-多态\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-3-多态\"}},[a._v(\"#\")]),a._v(\" 20.3 多态\")]),a._v(\" \"),_(\"p\",[a._v(\"多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"对多态的理解\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对多态的理解\"}},[a._v(\"#\")]),a._v(\" 对多态的理解：\")]),a._v(\" \"),_(\"p\",[a._v(\"当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass();，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。\")]),a._v(\" \"),_(\"h3\",{attrs:{id:\"多态的三个必要条件\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多态的三个必要条件\"}},[a._v(\"#\")]),a._v(\" 多态的三个必要条件：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"要有继承或者实现\")]),a._v(\" \"),_(\"li\",[a._v(\"要有重写\")]),a._v(\" \"),_(\"li\",[a._v(\"父类的引用指向子类的对象\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_21-引用数据类型的转换\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_21-引用数据类型的转换\"}},[a._v(\"#\")]),a._v(\" 21. 引用数据类型的转换\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"向上转型\")]),a._v(\"（自动类型转换）：子类转换成父类\")]),a._v(\" \"),_(\"p\",[a._v(\"特点：损失了子类扩展的属性和方法，只能使用父类中继承的属性和方法。\")]),a._v(\" \"),_(\"hr\"),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"向下转型\")]),a._v(\"（强制类型转换）：将父类对象显示的转换成子类对象\")]),a._v(\" \"),_(\"p\",[a._v(\"特点：想要向下转型必须要经过一次向上转型，发生向下转型后字了可以调用父类中的属性和方法，自己的属性和方法也可以调用。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_22-抽象\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_22-抽象\"}},[a._v(\"#\")]),a._v(\" 22. 抽象\")]),a._v(\" \"),_(\"p\",[a._v(\"抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_23-类和对象的关系\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_23-类和对象的关系\"}},[a._v(\"#\")]),a._v(\" 23. 类和对象的关系\")]),a._v(\" \"),_(\"p\",[a._v(\"类是一组具有相同属性和行为的对象的抽象，对象是描述客观事物的一个实体\")]),a._v(\" \"),_(\"p\",[a._v(\"类的作用是以模板的角色去创建对象，对象是类的实例\")]),a._v(\" \"),_(\"p\",[a._v(\"类中定义的属性在对象中被赋值，类中定义的方法行为，在对象中被激活。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_24-变量分类\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_24-变量分类\"}},[a._v(\"#\")]),a._v(\" 24. 变量分类\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"在类中、方法外定义的变量\")]),a._v(\"叫做成员变量，在本类中都可以被访问。\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"在方法中定义的变量\")]),a._v(\"叫局部变量，只能在本方法中被访问。\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"类中声明为static的属性\")]),a._v(\"叫做静态变量\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_25-static的用法\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_25-static的用法\"}},[a._v(\"#\")]),a._v(\" 25. Static的用法\")]),a._v(\" \"),_(\"p\",[a._v(\"用法1：static修饰方法>静态方法，不能访问类的非静态成员变量和非静态成员方法，反过来可以\")]),a._v(\" \"),_(\"p\",[a._v(\"用法2：static修饰变量>静态变量，被所有对象共享，在内存中只有一个副本，仅在类初次加载被初始化\")]),a._v(\" \"),_(\"p\",[a._v(\"用法3：static修饰代码块，类中可以有多个static块，在类初次被加载时，会按照static块的顺序来依次执行每个static块，并且只会执行一次。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"static的注意事项\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#static的注意事项\"}},[a._v(\"#\")]),a._v(\" static的注意事项\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"静态方法里只能直接访问静态成员，不能直接访问类中的非静态成员\")]),a._v(\" \"),_(\"li\",[a._v(\"静态方法中不能使用this、super关键字\")]),a._v(\" \"),_(\"li\",[a._v(\"静态方法不能被非静态方法覆盖，静态方法不能修饰构造器\")])]),a._v(\" \"),_(\"h3\",{attrs:{id:\"什么是静态代码块\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是静态代码块\"}},[a._v(\"#\")]),a._v(\" 什么是静态代码块？\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"一个类中由static关键字修饰的，不包含在任何方法体中的代码块\")]),a._v(\" \"),_(\"li\",[a._v(\"当类被载入时，静态代码块被执行，且只执行一次\")]),a._v(\" \"),_(\"li\",[a._v(\"静态块经常用来进行类属性的初始化\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_26-构造器的特点和作用\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_26-构造器的特点和作用\"}},[a._v(\"#\")]),a._v(\" 26. 构造器的特点和作用\")]),a._v(\" \"),_(\"p\",[a._v(\"特点：同类名、无返回值、访问权限一般是public\")]),a._v(\" \"),_(\"p\",[a._v(\"作用：完成对象的创建、实例化，通过构造器的形参可以对成员变量赋值\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_27-构造方法能不能重写\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_27-构造方法能不能重写\"}},[a._v(\"#\")]),a._v(\" 27. 构造方法能不能重写？\")]),a._v(\" \"),_(\"p\",[_(\"strong\",[a._v(\"不能\")]),a._v(\"。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_28-this关键字\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_28-this关键字\"}},[a._v(\"#\")]),a._v(\" 28. this关键字\")]),a._v(\" \"),_(\"p\",[a._v(\"用法1：\"),_(\"strong\",[a._v(\"this.属性\")]),a._v(\" 当局部变量和成员变量出现了重名问题，Java会根据就近原则，优先使用局部变量，例如构造方法中，非要使用成员变量的话，可以使用this关键字进行区分\")]),a._v(\" \"),_(\"p\",[a._v(\"用法2：\"),_(\"strong\",[a._v(\"this.方法\")]),a._v(\" 除了静态方法中不可使用，本类其他方法包括私有方法均可使用此格式调用其他方法，只是我们通常省略this关键字。\")]),a._v(\" \"),_(\"p\",[a._v(\"用法3：\"),_(\"strong\",[a._v(\"this()\")]),a._v(\" 用于构造方法内，例如可以在无参构造内调用含参构造，那么这时候就需要在this()传入参数来实现，同理要想在含参构造内调用无参构造，只需在构造器代码第一行写this()即可，但this()与this(参数列表)不可同时使用！\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_29-权限访问操作符\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_29-权限访问操作符\"}},[a._v(\"#\")]),a._v(\" 29. 权限访问操作符\")]),a._v(\" \"),_(\"p\",[a._v(\"只有default和public能够用来修饰类。修饰类的变量和方法四种权限都可以。\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"修饰类\\n\"),_(\"ul\",[_(\"li\",[a._v(\"default：表示在同一包中其他类都可以访问该类。\")]),a._v(\" \"),_(\"li\",[a._v(\"public：表示任何一个类都可以访问该类。\")])])]),a._v(\" \"),_(\"li\",[a._v(\"修饰方法和变量：\\n\"),_(\"ul\",[_(\"li\",[a._v(\"private：只能在本类访问，其他类不能访问。\")]),a._v(\" \"),_(\"li\",[a._v(\"default：只能在同包的类中可以访问到类的方法和变量，而不同包的类则不能访问类的方法和变量。\")]),a._v(\" \"),_(\"li\",[a._v(\"protected：既能提供本类访问，又能提供给不同包继承于此类的类访问方法和变量。\")]),a._v(\" \"),_(\"li\",[a._v(\"public：任意类能访问方法和变量。\")])])])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_30-final关键字的作用\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_30-final关键字的作用\"}},[a._v(\"#\")]),a._v(\" 30. final关键字的作用\")]),a._v(\" \"),_(\"p\",[a._v(\"修饰类，不能被继承\")]),a._v(\" \"),_(\"p\",[a._v(\"修饰变量，不能被重新赋值\")]),a._v(\" \"),_(\"p\",[a._v(\"修饰方法，不能被重写\")]),a._v(\" \"),_(\"blockquote\",[_(\"p\",[a._v(\"常量命名规范，所有字母大写，单词之间用下划线\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_31-abstract抽象类和抽象方法\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_31-abstract抽象类和抽象方法\"}},[a._v(\"#\")]),a._v(\" 31. abstract抽象类和抽象方法\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"抽象类的规则\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#抽象类的规则\"}},[a._v(\"#\")]),a._v(\" 抽象类的规则：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"抽象类不能被实例化\")]),a._v(\" \"),_(\"li\",[a._v(\"父类中包含的抽象方法必须在子类中实现，否则子类声明成抽象方法\")]),a._v(\" \"),_(\"li\",[a._v(\"抽象方法不能用static修饰\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"在什么情况下必须声明成抽象类\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在什么情况下必须声明成抽象类\"}},[a._v(\"#\")]),a._v(\" 在什么情况下必须声明成抽象类？\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"当类中有抽象方法时\")]),a._v(\" \"),_(\"li\",[a._v(\"当类是抽象类的子类且没有实现父类的所有抽象方法\")]),a._v(\" \"),_(\"li\",[a._v(\"当一个类实现一个接口且不能为全部抽象方法都提供实现时\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_32-接口\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_32-接口\"}},[a._v(\"#\")]),a._v(\" 32. 接口\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"接口中只能包含常量和抽象方法\")]),a._v(\" \"),_(\"li\",[a._v(\"接口对类来说是一套规范，是一套行为协议；\")]),a._v(\" \"),_(\"li\",[a._v(\"接口不是类，不能被实例化\")]),a._v(\" \"),_(\"li\",[a._v(\"接口中默认常量的修饰是：public static final\")]),a._v(\" \"),_(\"li\",[a._v(\"接口中的方法默认是abstract\")]),a._v(\" \"),_(\"li\",[a._v(\"接口可以但继承接口也可以继承多个接口，不能继承类\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"类和接口的特点\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类和接口的特点\"}},[a._v(\"#\")]),a._v(\" 类和接口的特点：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"为了使用一个接口，你要编写实现接口的类\")]),a._v(\" \"),_(\"li\",[a._v(\"如果一个类要实现一个接口，那么这个类就必须实现接口中所有抽象方法。否则这个类只能声明为抽象类\")]),a._v(\" \"),_(\"li\",[a._v(\"多个无关的类可以实现一个接口，一个类可以实现多个无关的接口\")]),a._v(\" \"),_(\"li\",[a._v(\"一个类可以在继承一个父类的同时，实现一个或多个接口\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_33-接口和抽象类的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_33-接口和抽象类的区别\"}},[a._v(\"#\")]),a._v(\" 33. 接口和抽象类的区别\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"从设计目的上来说-二者有如下的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从设计目的上来说-二者有如下的区别\"}},[a._v(\"#\")]),a._v(\" 从设计目的上来说，二者有如下的区别：\")]),a._v(\" \"),_(\"p\",[a._v(\"接口体现的是一种规范：\")]),a._v(\" \"),_(\"p\",[a._v(\"对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。\")]),a._v(\" \"),_(\"p\",[a._v(\"当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。\")]),a._v(\" \"),_(\"hr\"),a._v(\" \"),_(\"p\",[a._v(\"抽象类体现的是一种模板式设计：\")]),a._v(\" \"),_(\"p\",[a._v(\"抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"从使用方式上来说-二者有如下的区别\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从使用方式上来说-二者有如下的区别\"}},[a._v(\"#\")]),a._v(\" 从使用方式上来说，二者有如下的区别：\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。\")]),a._v(\" \"),_(\"li\",[a._v(\"接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。\")]),a._v(\" \"),_(\"li\",[a._v(\"接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。\")]),a._v(\" \"),_(\"li\",[a._v(\"接口里不能包含初始化块；但抽象类则完全可以包含初始化块。\")]),a._v(\" \"),_(\"li\",[a._v(\"一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_34-内存模型-待补充\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_34-内存模型-待补充\"}},[a._v(\"#\")]),a._v(\" 34. 内存模型（待补充）\")]),a._v(\" \"),_(\"p\",[a._v(\"栈：存取速度比堆快、效率高，栈内保存\"),_(\"strong\",[a._v(\"基本数据类型的局部变量\")]),a._v(\"和\"),_(\"strong\",[a._v(\"对象的引用\")]),a._v(\"，值先进后出，使用完毕立即回收\")]),a._v(\" \"),_(\"p\",[a._v(\"堆：保存对空间要求较大的变量，例如对象的属性和数组的元素，先进先出，在堆内存中开辟空间，只能通过new。数据使用完毕后，会在垃圾回收期空闲的时候回被回收\")]),a._v(\" \"),_(\"p\",[a._v(\"java中在类的实例化过程中，内存中会使用这三个区域，栈区，堆区和方法区。\")]),a._v(\" \"),_(\"ul\",[_(\"li\",[a._v(\"首先，累加载器在方法区加载Class信息，类中的成员变量和方法体进入到\"),_(\"strong\",[a._v(\"方法区\")]),a._v(\"。\")]),a._v(\" \"),_(\"li\",[a._v(\"mian()方法体进入栈内存（压栈）\")]),a._v(\" \"),_(\"li\",[a._v(\"在堆内存开辟内存空间，用于存放类的实例对象，将成员变量和成员方法的地址值放到new实例中\")]),a._v(\" \"),_(\"li\",[a._v(\"没太懂、没写完....\")])]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_35-gc垃圾回收机制\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_35-gc垃圾回收机制\"}},[a._v(\"#\")]),a._v(\" 35. GC垃圾回收机制\")]),a._v(\" \"),_(\"p\",[a._v(\"在Java内存运行时区域的各个部分中，堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，我们平时所说的内存分配与回收也仅仅特指这一部分内存。\")]),a._v(\" \"),_(\"h2\",{attrs:{id:\"_36-对象在什么情况下变成垃圾\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_36-对象在什么情况下变成垃圾\"}},[a._v(\"#\")]),a._v(\" 36. 对象在什么情况下变成垃圾\")]),a._v(\" \"),_(\"p\",[a._v(\"一个对象被强引用，不会回收\")]),a._v(\" \"),_(\"p\",[a._v(\"一个对象被软引用，如果内存不足就会回收\")]),a._v(\" \"),_(\"p\",[a._v(\"一个对象被弱引用不管当前内存空间是否足够，只要gc扫描到随时会回收\")]),a._v(\" \"),_(\"p\",[a._v(\"一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收\")])])}),[],!1,null,null,null);_.default=s.exports}}]);","extractedComments":[]}