{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{275:function(a,t,e){\"use strict\";e.r(t);var _=e(10),v=Object(_.a)({},(function(){var a=this,t=a._self._c;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"_1-java中有哪些容器-集合类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-java中有哪些容器-集合类\"}},[a._v(\"#\")]),a._v(\" 1. Java中有哪些容器（集合类）\")]),a._v(\" \"),t(\"p\",[a._v(\"Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection接口又派生出三个子接口，分别是Set、List、Queue。所有的Java集合类，都是Set、List、Queue、Map这四个接口的实现类，这四个接口将集合分成了四大类，其中\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"Set代表无序的，元素不可重复的集合；\")]),a._v(\" \"),t(\"li\",[a._v(\"List代表有序的，元素可以重复的集合；\")]),a._v(\" \"),t(\"li\",[a._v(\"Queue代表先进先出（FIFO）的队列；\")]),a._v(\" \"),t(\"li\",[a._v(\"Map代表具有映射关系（key-value）的集合。\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_2-集合和数组的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-集合和数组的区别\"}},[a._v(\"#\")]),a._v(\" 2. 集合和数组的区别:\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"数组也是容器，是定长的，访问较快。但是不能自动扩容\")]),a._v(\" \"),t(\"li\",[a._v(\"集合不是定长的，可以自动扩容\")]),a._v(\" \"),t(\"li\",[a._v(\"数组可以包含基本数据类型和引用数据类型，但是集合只能包含引用数据类型\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_3-arraylist和linkedlist的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-arraylist和linkedlist的区别\"}},[a._v(\"#\")]),a._v(\" 3. ArrayList和LinkedList的区别：\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"ArrayList类实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高\")]),a._v(\" \"),t(\"li\",[a._v(\"LinkedList类采用双向链表存储方式。插入、删除元素时效率比较高\")]),a._v(\" \"),t(\"li\",[a._v(\"LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_4-说一说treeset和hashset的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-说一说treeset和hashset的区别\"}},[a._v(\"#\")]),a._v(\" 4. 说一说TreeSet和HashSet的区别\")]),a._v(\" \"),t(\"p\",[a._v(\"HashSet、TreeSet中的元素都是不能重复的，并且它们都是线程不安全的，二者的区别是：\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"HashSet中的元素可以是null，但TreeSet中的元素不能是null\")]),a._v(\" \"),t(\"li\",[a._v(\"HashSet不能保证元素的排列顺序，而TreeSet支持自然排序、定制排序两种排序的方式\")]),a._v(\" \"),t(\"li\",[a._v(\"HashSet底层是采用哈希表实现的，而TreeSet底层是采用红黑树实现的\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_5-iterator\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-iterator\"}},[a._v(\"#\")]),a._v(\" 5. Iterator\")]),a._v(\" \"),t(\"p\",[a._v(\"实现集合的遍历，迭代器 it 的基本操作是 next 、hasNext 和 remove。\")]),a._v(\" \"),t(\"p\",[a._v(\"调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。\")]),a._v(\" \"),t(\"p\",[a._v(\"调用 it.hasNext() 用于检测集合中是否还有元素。\")]),a._v(\" \"),t(\"p\",[a._v(\"调用 it.remove() 将迭代器返回的元素删除。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_6-说一说hashmap和hashtable的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-说一说hashmap和hashtable的区别\"}},[a._v(\"#\")]),a._v(\" 6. 说一说HashMap和HashTable的区别\")]),a._v(\" \"),t(\"p\",[a._v(\"Hashtable是一个线程安全的Map实现，但HashMap是线程不安全的实现，所以HashMap比Hashtable的性能高一点\")]),a._v(\" \"),t(\"p\",[a._v(\"Hashtable不允许使用null作为key和value，如果试图把null值放进Hashtable中，将会引发空指针异常，但HashMap可以使用null作为key或value\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_7-为什么出现泛型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-为什么出现泛型\"}},[a._v(\"#\")]),a._v(\" 7. 为什么出现泛型？\")]),a._v(\" \"),t(\"p\",[a._v(\"泛型就是集合添加数据的类型约束。\")]),a._v(\" \"),t(\"p\",[a._v(\"集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。\"),t(\"code\",[a._v(\"Collection<E>\")]),a._v(\"，\"),t(\"code\",[a._v(\"List<E>\")]),a._v(\"，\"),t(\"code\",[a._v(\"ArrayList<E>\")]),a._v(\"这个\"),t(\"code\",[a._v(\"<E>\")]),a._v(\"就是类型参数，即泛型。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_8-介绍一下java中的io流\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-介绍一下java中的io流\"}},[a._v(\"#\")]),a._v(\" 8. 介绍一下Java中的IO流\")]),a._v(\" \"),t(\"p\",[a._v(\"IO（Input Output）用于实现对数据的输入与输出操作，Java把不同的输入/输出源（键盘、文件、网络等）抽象表述为流（Stream）。流是从起源到接收的有序数据。\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"按照数据流向，可以将流分为输入流和输出流，其中输入流只能读取数据，而输出流只能写入数据\")]),a._v(\" \"),t(\"li\",[a._v(\"按照数据类型，可以将流分为字节流和字符流，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。\")]),a._v(\" \"),t(\"li\",[a._v(\"按照处理功能，可以将流分为节点流和处理流，其中节点流可以直接从/向一个特定的IO设备（磁盘、网络等）读/写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也称为高级流。\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_9-流的4个父类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-流的4个父类\"}},[a._v(\"#\")]),a._v(\" 9. 流的4个父类\")]),a._v(\" \"),t(\"p\",[a._v(\"字节输入流的父类：Inputstream\")]),a._v(\" \"),t(\"p\",[a._v(\"字节输出流：Outputstream\")]),a._v(\" \"),t(\"p\",[a._v(\"字符输入流：Reader\")]),a._v(\" \"),t(\"p\",[a._v(\"字符输出流：Writer\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_10-怎么用流打开一个大文件\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-怎么用流打开一个大文件\"}},[a._v(\"#\")]),a._v(\" 10. 怎么用流打开一个大文件？\")]),a._v(\" \"),t(\"p\",[a._v(\"打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采用分次读取的方式。\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"使用缓冲流。缓冲流内部维护了一个缓冲区，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它每次会读取一批数据将缓冲区填满，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备。\")]),a._v(\" \"),t(\"li\",[a._v(\"使用NIO。NIO采用内存映射文件的方式来处理输入/输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多。\")])]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_11-介绍一下java的序列化与反序列化\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11-介绍一下java的序列化与反序列化\"}},[a._v(\"#\")]),a._v(\" 11. 介绍一下Java的序列化与反序列化\")]),a._v(\" \"),t(\"p\",[a._v(\"序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。其中，对象的序列化（Serialize），是指将一个Java对象写入IO流中，对象的反序列化（Deserialize），则是指从IO流中恢复该Java对象。\")]),a._v(\" \"),t(\"p\",[a._v(\"若对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。\")]),a._v(\" \"),t(\"p\",[a._v(\"若要实现序列化，则需要使用对象流ObjectInputStream和ObjectOutputStream。其中，在序列化时需要调用ObjectOutputStream对象的writeObject()方法，以输出对象序列。在反序列化时需要调用ObjectInputStream对象的readObject()方法，将对象序列恢复为对象。\")]),a._v(\" \"),t(\"h2\",{attrs:{id:\"_12-serializable接口为什么需要定义serialversionuid变量\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12-serializable接口为什么需要定义serialversionuid变量\"}},[a._v(\"#\")]),a._v(\" 12. Serializable接口为什么需要定义serialVersionUID变量？\")]),a._v(\" \"),t(\"p\",[a._v(\"serialVersionUID代表序列化的版本，通过定义类的序列化版本，在反序列化时，只要对象中所存的版本和当前类的版本一致，就允许做恢复数据的操作，否则将会抛出序列化版本不一致的错误。\")]),a._v(\" \"),t(\"p\",[a._v(\"如果不定义序列化版本，在反序列化时可能出现冲突的情况，例如：\")]),a._v(\" \"),t(\"ul\",[t(\"li\",[a._v(\"创建该类的实例，并将这个实例序列化，保存在磁盘上；\")]),a._v(\" \"),t(\"li\",[a._v(\"升级这个类，例如增加、删除、修改这个类的成员变量；\")]),a._v(\" \"),t(\"li\",[a._v(\"反序列化该类的实例，即从磁盘上恢复修改之前保存的数据。\")])]),a._v(\" \"),t(\"p\",[a._v(\"在第3步恢复数据的时候，当前的类已经和序列化的数据的格式产生了冲突，可能会发生各种意想不到的问题。增加了序列化版本之后，在这种情况下则可以抛出异常，以提示这种矛盾的存在，提高数据的安全性。\")])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}