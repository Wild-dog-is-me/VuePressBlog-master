{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{277:function(t,r,_){\"use strict\";_.r(r);var a=_(10),v=Object(a.a)({},(function(){var t=this,r=t._self._c;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[r(\"h2\",{attrs:{id:\"_1-数组的内存结构\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-数组的内存结构\"}},[t._v(\"#\")]),t._v(\" 1. 数组的内存结构\")]),t._v(\" \"),r(\"p\",[t._v(\"数组是一个引用数据类型，和对象相同，栈中存储的是引用数据类型的地址。堆中存储的是值。\")]),t._v(\" \"),r(\"p\",[t._v(\"当创建一个数组是（即new一个数组），首先在栈空间出现数组名，在堆空间开辟出连续的存储空间，并且数组名指向连续存储空间的首地址，存储空间的存储值均为默认值\")]),t._v(\" \"),r(\"p\",[t._v(\"在声明数组的时候并没有为数组进行开辟储存的空间，需要为其分配空间就必须为其初始化，初始化的方式有两种：第一种就是直接赋值；第二种就是使用new 来为数组初始化；在使用关键字new的时候只是对数组进行了开辟空间但是并没有为其赋值\")]),t._v(\" \"),r(\"p\",[t._v(\"二维数组的内存实则和一维数组没有本质区别。只是将一维数组存的数据改为了另一个数组的首地址。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_2-数组容易产生的异常\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-数组容易产生的异常\"}},[t._v(\"#\")]),t._v(\" 2. 数组容易产生的异常\")]),t._v(\" \"),r(\"p\",[t._v(\"数组下标越界，循环的长度超出了数组本身的长度\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_3-异常的定义\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-异常的定义\"}},[t._v(\"#\")]),t._v(\" 3. 异常的定义\")]),t._v(\" \"),r(\"p\",[t._v(\"运行期间出现的错误。而不是编译时的语法错误。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_4-异常的层次结构\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-异常的层次结构\"}},[t._v(\"#\")]),t._v(\" 4. 异常的层次结构\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"throwable\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#throwable\"}},[t._v(\"#\")]),t._v(\" Throwable：\")]),t._v(\" \"),r(\"p\",[t._v(\"Throwable 是 Java 语言中所有错误与异常的超类。\")]),t._v(\" \"),r(\"p\",[t._v(\"Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\")]),t._v(\" \"),r(\"p\",[t._v(\"Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"error-错误\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#error-错误\"}},[t._v(\"#\")]),t._v(\" Error（错误）\")]),t._v(\" \"),r(\"p\",[t._v(\"Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\")]),t._v(\" \"),r(\"p\",[t._v(\"此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\")]),t._v(\" \"),r(\"p\",[t._v(\"这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，不应该实现任何新的Error子类\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"exception-异常\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#exception-异常\"}},[t._v(\"#\")]),t._v(\" Exception（异常）\")]),t._v(\" \"),r(\"p\",[t._v(\"程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[t._v(\"运行时异常\")])])]),t._v(\" \"),r(\"p\",[t._v(\"都是RuntimeException类及其子类异常，如NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\")]),t._v(\" \"),r(\"p\",[t._v(\"运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[t._v(\"非运行时异常\")]),t._v(\" （编译异常）\")])]),t._v(\" \"),r(\"p\",[t._v(\"是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"可查的异常-checked-exceptions-和不可查的异常-unchecked-exceptions\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可查的异常-checked-exceptions-和不可查的异常-unchecked-exceptions\"}},[t._v(\"#\")]),t._v(\" 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[t._v(\"可查异常\")]),t._v(\"（编译器要求必须处置的异常）：\")])]),t._v(\" \"),r(\"p\",[t._v(\"可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。\")]),t._v(\" \"),r(\"p\",[t._v(\"除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[r(\"strong\",[t._v(\"不可查异常\")]),t._v(\"(编译器不要求强制处置的异常)\")])]),t._v(\" \"),r(\"p\",[t._v(\"包括运行时异常（RuntimeException与其子类）和错误（Error）。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_5-常见的异常类型\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-常见的异常类型\"}},[t._v(\"#\")]),t._v(\" 5. 常见的异常类型\")]),t._v(\" \"),r(\"p\",[t._v(\"空指针异常类：NullPointerException\")]),t._v(\" \"),r(\"p\",[t._v(\"数据类型转换异常：java.lang.ClassCastException\")]),t._v(\" \"),r(\"p\",[t._v(\"没有访问权限：java.lang.IllegalAccessException\")]),t._v(\" \"),r(\"p\",[t._v(\"方法的参数错误：java.lang.IllegalArgumentException\")]),t._v(\" \"),r(\"p\",[t._v(\"数组下标越界异常：java.lang.IndexOutOfBoundsException\")]),t._v(\" \"),r(\"p\",[t._v(\"文件已结束异常：EOFException\")]),t._v(\" \"),r(\"p\",[t._v(\"文件未找到异常：FileNotFoundException\")]),t._v(\" \"),r(\"p\",[t._v(\"字符串转换为数字异常：NumberFormatException\")]),t._v(\" \"),r(\"p\",[t._v(\"指定的类不存在： java.lang.ClassNotFoundException\")]),t._v(\" \"),r(\"p\",[t._v(\"实例化异常：java.lang.InstantiationException\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_6-异常机制\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-异常机制\"}},[t._v(\"#\")]),t._v(\" 6. 异常机制\")]),t._v(\" \"),r(\"p\",[t._v(\"关于异常处理：\")]),t._v(\" \"),r(\"p\",[t._v(\"try、catch、finally。其中，try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，比如数据库连接、网络连接、磁盘文件等，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。\")]),t._v(\" \"),r(\"p\",[t._v(\"关于抛出异常：\")]),t._v(\" \"),r(\"p\",[t._v(\"当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。\")]),t._v(\" \"),r(\"p\",[t._v(\"关于异常跟踪栈：\")]),t._v(\" \"),r(\"p\",[t._v(\"程序运行时，一系列方法调用形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_7-自定义异常\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-自定义异常\"}},[t._v(\"#\")]),t._v(\" 7. 自定义异常\")]),t._v(\" \"),r(\"p\",[t._v(\"用户自定义的异常类应为Exception类或其子类\")]),t._v(\" \"),r(\"p\",[t._v(\"习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_8-object类\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-object类\"}},[t._v(\"#\")]),t._v(\" 8. Object类\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[t._v(\"Object是所有类的超类，是java语言中唯一一个没有父类的类\")]),t._v(\" \"),r(\"li\",[t._v(\"一个类可以不是Object的直接子类，但一定它的子类。Java中每一个类都是Object扩展来的。\")]),t._v(\" \"),r(\"li\",[t._v(\"在Object类中定义的方法，在其他类中都可以使用。\")])]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_9-和equals-有什么区别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-和equals-有什么区别\"}},[t._v(\"#\")]),t._v(\" 9. ==和equals()有什么区别？\")]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"参考答案\")])]),t._v(\" \"),r(\"p\",[t._v(\"==运算符：\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[t._v(\"作用于基本数据类型时，是比较两个数值是否相等；\")]),t._v(\" \"),r(\"li\",[t._v(\"作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；\")])]),t._v(\" \"),r(\"p\",[t._v(\"equals()方法：\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[t._v(\"没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；\")]),t._v(\" \"),r(\"li\",[t._v(\"进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。\")])]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_10-为什么要有包装类\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-为什么要有包装类\"}},[t._v(\"#\")]),t._v(\" 10. 为什么要有包装类\")]),t._v(\" \"),r(\"p\",[t._v(\"Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型不具备对象的特性。为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_11-包装类的特点\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11-包装类的特点\"}},[t._v(\"#\")]),t._v(\" 11. 包装类的特点\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[t._v(\"不把基本数据类型看做对象，但是每个基本数据类型又有一个对应的封装类\")]),t._v(\" \"),r(\"li\",[t._v(\"包装类可以完成数据类型之间的转换\")]),t._v(\" \"),r(\"li\",[t._v(\"包装类，封装了一些处理基本数据类型的属性和方法\")]),t._v(\" \"),r(\"li\",[t._v(\"包装类的工能比基本数据类型的功能要强大\")])]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_12-自动装箱和自动拆箱的应用场景\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12-自动装箱和自动拆箱的应用场景\"}},[t._v(\"#\")]),t._v(\" 12. 自动装箱和自动拆箱的应用场景\")]),t._v(\" \"),r(\"p\",[t._v(\"自动装箱、自动拆箱是JDK1.5提供的功能。\")]),t._v(\" \"),r(\"p\",[t._v(\"自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；\")]),t._v(\" \"),r(\"p\",[t._v(\"自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；\")]),t._v(\" \"),r(\"p\",[t._v(\"通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_13-string可以被继承吗\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_13-string可以被继承吗\"}},[t._v(\"#\")]),t._v(\" 13. String可以被继承吗？\")]),t._v(\" \"),r(\"p\",[t._v(\"String类由final修饰，所以不能被继承。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_14-说一说string和stringbuffer有什么区别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_14-说一说string和stringbuffer有什么区别\"}},[t._v(\"#\")]),t._v(\" 14. 说一说String和StringBuffer有什么区别\")]),t._v(\" \"),r(\"p\",[t._v(\"String类是不可变类，一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。\")]),t._v(\" \"),r(\"p\",[t._v(\"StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_15-string类型的创建方式-推荐用哪种方式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_15-string类型的创建方式-推荐用哪种方式\"}},[t._v(\"#\")]),t._v(\" 15. String类型的创建方式，推荐用哪种方式？\")]),t._v(\" \"),r(\"ul\",[r(\"li\",[t._v(\"静态方式的创建：直接给变量赋值： String str=”hello”，JVM将会使用常量池来管理这个字符串，如果常量池中已经存在该字符串对象则直接引用。\")]),t._v(\" \"),r(\"li\",[t._v('动态方式创建通过new创建：String str=new String(“hello”)，JVM会先使用常量池来管理 \"hello\" ，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。')])]),t._v(\" \"),r(\"p\",[t._v(\"显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用直接量的方式创建字符串。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_16-说一说stringbuffer和stringbuilder有什么区别\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_16-说一说stringbuffer和stringbuilder有什么区别\"}},[t._v(\"#\")]),t._v(\" 16. 说一说StringBuffer和StringBuilder有什么区别？\")]),t._v(\" \"),r(\"p\",[t._v(\"StringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑StringBuilder类。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"_17-说一说你对字符串拼接的理解\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_17-说一说你对字符串拼接的理解\"}},[t._v(\"#\")]),t._v(\" 17. 说一说你对字符串拼接的理解\")]),t._v(\" \"),r(\"p\",[t._v(\"运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接\")]),t._v(\" \"),r(\"p\",[t._v(\"StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder\")]),t._v(\" \"),r(\"p\",[t._v(\"StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer\")]),t._v(\" \"),r(\"p\",[t._v(\"String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法\")])])}),[],!1,null,null,null);r.default=v.exports}}]);","extractedComments":[]}